# GA17 Privacy Enhancing Technologies -- Lab 02

## Reminder of basic repository operations and testing

To update your local version in the virtual machine, go to the directory called `PET-Exercises` and type:

    $ git pull

To update your version of `petlib` type:

	$ sudo pip install petlib --upgrade

### Structure of Labs
The structure of all the labs will be similar: two python files will be provided. 

- The first is named `Lab0XCode.py` and contains the structure of the code you need to complete. 
- The second is named `Lab0XTests.py` and contains unit tests (written for the pytest library) that you may execute to partially check your answers. 

Note that the tests passing is a necessary but not sufficient condition to fulfill each task. There are programs that would make the tests pass that would still be invalid (or blatantly insecure) implementations.

The only dependency your Python code should have, besides pytest and the standard library, is the petlib library, which we specifically developed for this course (and also for our own use!). 

The petlib documentation is [available on-line here](http://petlib.readthedocs.org/en/latest/index.html).


### Working with unit tests
Unit tests are run from the command line by executing the command:

```
$ py.test -v Lab01Tests.py
```

Note the `-v` flag toggles a more verbose output. If you wish to inspect the output of the full tests run you may pipe this command to the `less` utility (execute `$ man less` for a full manual of less):

```
$ py.test -v Lab01Tests.py | less
```

You can also run a selection of tests associated with each task, by executing the command. the argument to the `-m` flag may be a task (from task1 to task5 for Lab 1).

```
$ py.test -v Lab01Tests.py -m task1
```

You may also select tests to run based on their name using the `-k` flag. Have a look at the test file to find out the function names of each test. For example the following command executes the very first test of Lab 1, since it matches its name `test_petlib_present`:

```
$ py.test -v Lab01Tests.py -k petlib
```

The full documentation of pytest is [available here](http://pytest.org/latest/).

## Lab 02 -- Basics of Engineering Mix Systems and Traffic Analysis

## TASK 1 -- Check installation

> Ensures that the key libraries may be loaded, and the code files are present. Nothing to do beyond ensuring this is the case.

## Task 2 -- Build a simple 1-hop mix client

> You are provided the code of the inner decoding function of a simple, one-hop mix server. Your task is to write a function that encodes a message to be send through the mix.

## Hints:

- You can run the tests just for this task by executing:

	py.test -v Lab02Tests.py -m task2

- Your objective is to complete the function `mix_client_one_hop`. This function takes as inputs a public key (an EC element) of the mix, an address and a message. It must then encode the message to be processed by the `mix_server_one_hop` in such a way that the mix will output a tuple of (address, message) to be routed to its final destination.

- The message type is a Python NamedTuple already defined for you as `OneHopMixMessage`. The function `mix_client_one_hop` must return an object of this type. Such an object may be created simply by calling:

	OneHopMixMessage(client_public_key, expected_mac, address_cipher, message_cipher)

where the `client_public_key` is an EC point, the expected Hmac is an Hmac of the `address_cipher` and `message_cipher`, and those are AES Counter mode (AES-CTR) ciphertexts of the encoded address and message.

- Study the function `mix_server_one_hop` that implements the one-hop mix. Take note of all the `petlib` cryptographic operations and checked performed in order to process a message. You will have to ensure they decode your message correctly.

- The first element of a message is an ephemeral public key defined by the client (and the client knows its private part). The private key is used to derived a shared secret with the mix, using the mix public key. Study the code of the one-hop mix to examine the key derivation, and ensure your client mirrors it to generate messages that decode correctly.

- Study the code of the mix in `mix_server_one_hop` to determine the cryptographic operations necessary to encrypt correctly the address and message, as well as producing a valid Hmac.

- An Hmac isa cryptographic checksum that can be used to ensure parts of a message were generated by the holder of a shared secret key. If you are unsure of what a message authentication code does, do check the [HMAC primitive on wikipedia](http://en.wikipedia.org/wiki/Hash-based_message_authentication_code). You can find functions to generate and check Hmac in `petlib.hmac'.